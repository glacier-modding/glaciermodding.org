---
sidebar_position: 3
description: The Resource management system in Glacier explained
---

# Resource management

## Resource Partitions

### Packages and parittions

The game's data is split into `package` files, which have an `.rpkg` extension. They commonly use either `chunk` or `dlc` as followed by an index as name. These packages contain all the assets the game uses. Each of these "base" packages can also be accompanied by "patch" packages, which will postfix patchX to the filename (e.g. `chunk0patch2.rpkg`, `dlc2patch5`). 
A base package together with its patch packages is called a partition.

To share content between partitions a `packagedefinition.txt` file is used. This file must be present inside the same folder the packages are in.

When the game tries to load a level it will try to find the partition that level is in, using the `packagedefinition.txt` file. 

A partition can access all of the resource it stores, and all of the resources stored by its parent, recursively. This means that the resources in the root partition (usually `chunk0`) are always "globally" accessible,

#### Special package usages:
- Language partitions: In the Hitman 2016 japanese dlc you can find special language dlc package. These use the `chunk0langjp.rpkg` -> `chunk0langjppatch1.rpkg` format and behave like normal dlc partitions.
- Overflow packages: Hitman 3 VR: Reloaded, developed by XR games, contains the `chunk0.rpkg` -> `chunk0overflow0.rpkg` format. These packages overflow are used to get around the FAT32 limit on the Quest 3.
- Part packages: Hitman 3: IOS edition contains `chunk0part1.rpkg` -> `chunk0part2.rpkg` format. Despite the "part" in the name these are still standalone resource packages. Their use is likely related to the revamp of the resource management system on IOS, where storage is limited.

### Resource ids

#### Runtime Resource Id

To uniquely identify resources, the Glacier engine generates an ID derived from the resource's path. Instead of tracking resource paths directly the engine uses a **Runtime Resource ID (RRID)**. This is a 64-bit hash value usually represented in hex (`0x00123456789ABCDE`). These RRIDs serve as small and efficient references to resources within the engine. Originally these values were often referred to as a resource's hash.

#### Resource Id

A **Runtime Resource ID** is generated from a **Resource ID**. Resource IDs are structured paths that include additional information about the resource, such as platform tags, parameters, and derived extensions. This structure enables the resource pipeline to efficiently track, derive, and manipulate resources.

##### Resource ID examples
- Simple resourceID example without parameters
    ```
    [assembly:/images/sprites/player.jpg].pc_jpeg
    ```

    In this example, the **source** path `assembly:/images/sprites/player.jpg` was used to  generate a ResourceID. This ID is **derived** for the `pc` platform and specifies a  `jpeg` extension.

- Nested resourceID with derived IDs and parameters:
    ```
    [[assembly:/images/sprites/player.jpg](asspritesheet).png].orbis_gif
    ```

    Here, `assembly:/images/sprites/player.jpg` was the **source** resource, which was used to generate an **intermediate** `.png` resource with the `asspritesheet` parameter. This **intermediate** resource was then used to **derive** a `.gif` format resource for the `orbis` (ps4) platform.

- Complex resourceID with multiple levels of nesting and parameters:
    ```
    [[[assembly:/materials/materialclasses/test.materialclass].fx](small).mate](dx12).pc_mate
    ```
    1. The **source** resource path `assembly:/materials/materialclasses/test.materialclass` was used to create an **intermediate** `.fx` resource.
    2. This `.fx` resource was further used to create another **intermediate** resource, `.mate`, with the `dx11` parameter.
    3. Finally, this `.mate` resource was **derived** as a `pc` platform-specific resource with the `mate` extension and the `dx12` parameter.

---

Multiple ResourceID can be derived from the same Source resource:
```
[assembly:/scenes/missions/test/practice_mission.entity].pc_entitytemplate
[assembly:/scenes/missions/test/practice_mission.entity].pc_entityblueprint
[assembly:/scenes/missions/test/practice_mission.entity].pc_preload
```
In this case, a single entity file is used to generate different resources specific to templates, blueprints, and preload data for the PC platform.

To generate a RuntimeResourceID from a ResourceID, a md5 digest is used.
1. The Resource ID string is hashed using MD5, resulting in a 128-bit digest.
2. The Runtime Resource ID is generated by extracting the lower 64 bits and setting the lower 8 bits to zero.
   
example:
```
ResourceID:        [assembly:/images/sprites/player.jpg].pc_jpeg
Md5 digest:        4c56778efc29f02772b6219b270a8fb7
RuntimeResourceID: 0056778EFC29F027
```